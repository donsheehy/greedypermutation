# Searching in a Balltree

```python {cmd id="setup" hide}
from random import randrange, seed
from greedypermutation.balltree import Ball
from metricspaces import MetricSpace
from ds2viz.canvas import svg_plus_pdf
from ds2viz.element import Line, Group
from greedypermutation.vizpoint import VizPoint as Point

W = 600
H = 200
N = 30

seed(0)
P = MetricSpace({Point(randrange(5, W//2), randrange(5,H-5)) for i in range(N)} | \
    {Point(randrange(W//2, W-5), randrange(5,H-5)) for i in range(5 * N)})

T = Ball.tree_greedy(P)

# print([str(p) for p in P])
```

To illustrate the search operations, we will use the following point set $P$.
It was generated by sampling random points from from a distribution in which the density is uniform on each side, but is five times greater on the right side.

```python {cmd continue="setup" output=html hide}
with svg_plus_pdf(W, H, 'points') as canvas:
    [Point(*p).draw(canvas) for p in P]
```

## Nearest Neighbor Search

```python {cmd continue="setup"}

q = Point(138, 92)
nn = T.nn(q)
```

```python {cmd continue output=html hide}
with svg_plus_pdf(W, H, 'nn_search') as canvas:
    # Draw the circle center at q extending to nn.
    Point(*q, q.dist(nn)).draw(canvas)
    # Draw the points.
    [Point(*p).draw(canvas) for p in P]
    # Draw q and nn.
    Point(*q, 3).draw(canvas)
    Point(*nn, 3).draw(canvas)
```


## Approximate Nearest Neighbor Search

```python {cmd continue="setup"}
q = Point(308, 82)
ann = T.ann(q, 2)
```

```python {cmd continue output=html hide}
with svg_plus_pdf(W, H, 'ann_search') as canvas:
    # Draw the circle center at q extending to ann.
    Point(*q, q.dist(ann)).draw(canvas)
    # Draw the points.
    [Point(*p).draw(canvas) for p in P]
    # Draw q and ann.
    Point(*q, 3).draw(canvas)
    Point(*ann, 3).draw(canvas)
```

## Range Search


```python {cmd continue="setup"}
q = Point(308, 82)
radius = 50
R = T.range_search(q, radius)
```

```python {cmd continue output=html hide}
with svg_plus_pdf(W, H, 'range_search') as canvas:
    # Draw the circle center at q extending to ann.
    Point(*q, radius).draw(canvas)
    # Draw the points.
    [Point(*p).draw(canvas) for p in P]
    [Point(*p, 2).draw(canvas) for p in R]
    # Draw q.
    Point(*q, 3).draw(canvas)

```

It is also possible to pass another parameter to the range search specifying some slack in the range.
This will terminate the search a little early, possibly returning some points in the ball with radius `radius + slack`.
The main reason for the slack parameter is in range counting, but it is available for range search as well.


```python {cmd continue="setup"}
q = Point(308, 82)
radius = 50
slack = 20
R = T.range_search(q, radius, slack)
```

```python {cmd continue output=html hide}
with svg_plus_pdf(W, H, 'range_search_with_slack') as canvas:
    # Draw the circle center at q extending to ann.
    Point(*q, radius + slack).draw(canvas)
    Point(*q, radius).draw(canvas)
    # Draw the points.
    [Point(*p).draw(canvas) for p in P]
    [Point(*p, 2).draw(canvas) for p in R]
    # Draw q.
    Point(*q, 3).draw(canvas)    
```

This may seem like an odd operation at first, because for points in the plane, it **is** an odd operation.
The range search iterates over all the points that are returned, so it is possible to filter them depending on whether or not they are in the range at that time.
However, for expensive metrics, one may not want to compute those distances.


## Range Counting

```python {cmd continue="setup"}
q = Point(308, 82)
radius = 50
count = T.range_count(q, radius)
```

```python {cmd continue output=html hide}
with svg_plus_pdf(W, H, 'range_search_with_slack') as canvas:
    # Draw the circle center at q extending to ann.
    # Point(*q, radius + slack).draw(canvas)
    Point(*q, radius).draw(canvas)
    # Draw the points.
    [Point(*p).draw(canvas) for p in P]
    R = T.range_search(q, radius)
    [Point(*p, 2).draw(canvas) for p in R]
    # Draw q.
    Point(*q, 3).draw(canvas)    

print("count = ", count)
```

```python {cmd continue="setup"}
q = Point(308, 82)
radius = 50
slack = 20
count = T.range_count(q, radius, slack)
```

```python {cmd continue output=html hide}
with svg_plus_pdf(W, H, 'range_search_with_slack') as canvas:
    # Draw the circle center at q extending to ann.
    Point(*q, radius + slack).draw(canvas)
    Point(*q, radius).draw(canvas)
    # Draw the points.
    [Point(*p).draw(canvas) for p in P]
    R = T.range_search(q, radius, slack)
    [Point(*p, 2).draw(canvas) for p in R]
    # Draw q.
    Point(*q, 3).draw(canvas)    

print("count = ", count)
```

## Range Sampling


## $k$th Nearest Neighbor

```python {cmd continue="setup" output=html}
q = Point(400, 51, 2)
k = 20
knn = list(T.knn(k, q))
# print(f"{len(knn)} points found, searched for {k}.")
r = max(nn.dist(q) for nn in knn)

with svg_plus_pdf(W, H, 'knn_search') as canvas:
    Point(*q, r).draw(canvas)
    [Point(*x, 4).draw(canvas) for x in knn]
    [Point(*p).draw(canvas) for p in P]
    q.draw(canvas)
```

## Approximate $k$th Nearest Neighbor

```python3 {cmd continue="setup" output=html}
q = Point(412, 51, 2)
k = 15
approx = 1.5
close_enough = (approx-1)/2
knn = list(T.knn(k, q))
knn2 = list(T.knn(k, q, approx))

# N, viable = T._knn(k, q, approx)
# viable = list(viable)
r = T.knn_dist(k,q)
# r2 = T.knn_dist(k,q, approx)
# stopping_radius = close_enough * N.radius
# for ball in viable:
#     assert(ball.radius < stopping_radius)

with svg_plus_pdf(W, H, 'knn_search') as canvas:
    # Point(*q, N.radius).draw(canvas)
    Point(*q, r).draw(canvas)
    # [Point(*ball.center, ball.radius).draw(canvas) for ball in viable]
    # [Point(*ball.center, ball.radius).draw(canvas) for ball in N]
    # Point(*knn[19], stopping_radius * r).draw(canvas)
    # [Point(*x, 5).draw(canvas) for x in knn]
    [Point(*x, 3).draw(canvas) for x in knn2]
    [Point(*p).draw(canvas) for p in P]
    q.draw(canvas)
```



## Farthest Point

```python {cmd continue="setup"}
q = Point(138, 92)
farthest = T.farthest_point(q)
# dist_to_farthest = q.dist(farthest)
```

```python {cmd continue output=html hide}
with svg_plus_pdf(W, H, 'farthest_search') as canvas:
    # Draw the circle center at q extending to farthest.
    Point(*q, q.dist(farthest)).draw(canvas)
    # Draw the points.
    [Point(*p).draw(canvas) for p in P]
    # Draw q and nn.
    Line(q, farthest).draw(canvas)
    Point(*q, 3).draw(canvas)
    Point(*farthest, 3).draw(canvas)
```
